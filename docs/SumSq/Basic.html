<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>basic</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Basic_files/libs/clipboard/clipboard.min.js"></script>
<script src="Basic_files/libs/quarto-html/quarto.js"></script>
<script src="Basic_files/libs/quarto-html/popper.min.js"></script>
<script src="Basic_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Basic_files/libs/quarto-html/anchor.min.js"></script>
<link href="Basic_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Basic_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Basic_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Basic_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Basic_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<section id="the-type-of-sums-of-squares" class="level1">
<h1>The type of sums of squares</h1>
<p>Copyright (c) 2023 Matematiflo. All rights reserved. Released under Apache 2.0 license as described in the file LICENSE. Authors: Florent Schaffhauser.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">SumSq.Defs</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Mathlib.Algebra.GroupPower.Basic</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let <code>R</code>be a semiring. In the file <a href="Defs.md">SumSq.Defs</a>, we declared a function <code>SumSq : List R → R</code> that computes the sum of squares of the entries of a list:</p>
<blockquote class="blockquote">
<p>SumSq [a, b, c] = a ^ 2 + b ^ 2 + c ^ 2</p>
</blockquote>
<p>In the present file, we declare a predicate <code>IsSumSq : R → Prop</code> that characterizes the elements of <code>R</code> that are return values of the function <code>SumSq</code>. We then discuss how to use such a predicate to declare sums of squares in <code>R</code> either as a subset or as a subtype of <code>R</code>.</p>
<section id="using-an-inductive-predicate" class="level2">
<h2 class="anchored" data-anchor-id="using-an-inductive-predicate">Using an inductive predicate</h2>
<p>Using a predicate on <code>R</code> (i.e.&nbsp;a function <code>IsSumSq : R → Prop</code>) to characterize sums of squares in <code>R</code> means the following: a term <code>S : R</code> will be called a sum of squares if the proposition <code>IsSumSq S</code> has a proof.</p>
<p>Below, the predicate <code>IsSumSq</code> is defined inductively, but later we will show that we can also define it <a href="#using-an-existential-predicate">existentially</a>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>inductive <span class="dt">IsSumSq</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] <span class="op">:</span> <span class="dt">R</span> → <span class="dt">Prop</span> <span class="op">:=</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> zero <span class="op">:</span> <span class="dt">IsSumSq</span> (<span class="dv">0</span> <span class="op">:</span> <span class="dt">R</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> add (x <span class="dt">S</span> <span class="op">:</span> <span class="dt">R</span>) (hS <span class="op">:</span> <span class="dt">IsSumSq</span> <span class="dt">S</span>) <span class="op">:</span> <span class="dt">IsSumSq</span> (x <span class="op">^</span> <span class="dv">2</span> <span class="op">+</span> <span class="dt">S</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>By definition of <code>IsSumSq</code>, the term <code>0 : R</code> is a sum of squares, and if <code>S : R</code> is a sum of squares and <code>x : R</code>, then <code>x ^ 2 + S</code> is a sum of squares. We can use this to prove that, for all list <code>L : List R</code>, the term <code>SumSq L : R</code> is a sum of squares.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>lemma <span class="dt">SumSqListIsSumSq</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] (<span class="dt">L</span> <span class="op">:</span> <span class="dt">List</span> <span class="dt">R</span>) <span class="op">:</span> <span class="dt">IsSumSq</span> (<span class="dt">SumSq</span> <span class="dt">L</span>) <span class="op">:=</span> by</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  induction <span class="dt">L</span> with  <span class="co">-- by induction on the list L</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> nil <span class="ot">=&gt;</span>  <span class="co">-- the case of the empty list []</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    rw [<span class="dt">SumSq</span>]  <span class="co">-- rewrite using SumSq [] = 0</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    exact IsSumSq.zero  <span class="co">-- IsSumSq 0 is a proof that 0 is a sum of squares</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> cons a l ih <span class="ot">=&gt;</span>  <span class="co">-- the case of a list L = (a :: l) where SumSq l is assumed to be a sum of squares</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    rw [<span class="dt">SumSq</span>]  <span class="co">-- rewrit using SumSq (a :: l) = a ^2 + SumSq l</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    exact IsSumSq.add a (<span class="dt">SumSq</span> l) ih  <span class="co">-- conclude using the induction hypothesis and the property that, if S is a sum of squares, then x ^2 + S is a sum of squares</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let us give three more examples of simple proofs that a term <code>S : R</code> is a sum of squares. Namely, we prove that <code>0 : R</code>, <code>1 : R</code> and all squares in <code>R</code> are sums of squares.</p>
<p>For more on this, see <a href="#exercise-1">Exercise 1</a>. And for more on Lemma <code>SumSqListIsSumSq</code>, see <a href="#exercise-2">Exercise 2</a>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>lemma zeroIsSumSq {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] <span class="op">:</span> <span class="dt">IsSumSq</span> (<span class="dv">0</span> <span class="op">:</span> <span class="dt">R</span>) <span class="op">:=</span> by</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  exact IsSumSq.zero  <span class="co">-- 0 is a sum of squares in R by definition of the type IsSumSq</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>lemma <span class="dt">SquareIsSumSq</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] (x <span class="op">:</span> <span class="dt">R</span>) <span class="op">:</span> <span class="dt">IsSumSq</span> (x <span class="op">^</span> <span class="dv">2</span>) <span class="op">:=</span> by</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  rw [← add_zero (x <span class="op">^</span><span class="dv">2</span>)]  <span class="co">-- rewrite using x ^ 2 = x ^ 2 + 0</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  exact IsSumSq.add x <span class="dv">0</span> IsSumSq.zero  <span class="co">-- x ^ 2 + 0 is a sum of squares in R by definition of the type IsSumSq (and because we have already proven that 0 is a sum squares)</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>lemma oneIsSumSq {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] <span class="op">:</span> <span class="dt">IsSumSq</span> (<span class="dv">1</span> <span class="op">:</span> <span class="dt">R</span>) <span class="op">:=</span> by</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  rw [← one_pow <span class="dv">2</span>]  <span class="co">-- rewrite using 1 = 1 ^ 2</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  exact <span class="dt">SquareIsSumSq</span> <span class="dv">1</span>  <span class="co">-- conclude using SquareIsSumSq</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Based on its declaration, the type <code>IsSumSq</code> behaves like a <code>Prop</code>-valued function on <code>R</code>. The only two subtleties are:</p>
<ul>
<li>the fact that the variable <code>R : Type</code> is implicit (between brackets of the form <code>{}</code>).</li>
<li>the fact that the assumption that <code>R</code> is a semiring is implemented using a class instance (between brackets of the form <code>[]</code>).</li>
</ul>
<p>For example, <code>IsSumSq ℤ 0</code> is the formalized version of the statement <code>0 is a sum of squares in ℤ</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#check @IsSumSq  -- @IsSumSq : {R : Type} → [hR : Semiring R] → R → Prop</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#check IsSumSq (0 : ℤ)  -- IsSumSq 0 : Prop</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Implementing class instance parameters is useful to <em>automatically</em> give meaning to expressions <code>(0 : R)</code> and <code>x ^ 2 + S</code> (since <code>R</code> is a semiring), via a process called <a href="https://lean-lang.org/theorem_proving_in_lean4/type_classes.html"><em>typeclass resolution</em></a>. Note that we could give that instantiation a name if we wanted to, by declaring <code>[hR : Semiring R]</code> instead of just <code>[Semiring R]</code>.</p>
<p>The fact that <code>IsSumSq</code> behaves like a function with an implicit parameter and a class instance parameter can be used to present the above checks differently.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#check @IsSumSq ℤ _  -- IsSumSq : ℤ → Prop</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#check @IsSumSq ℤ _ 0  -- IsSumSq 0 : Prop</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Since <code>IsSumSq</code> is declared as an inductive type, it automatically generates an induction principle accesible via <code>IsSumSq.rec</code>. This means that if we want to prove a result for all sums of squares in a semiring <code>R'</code>, it suffices to prove it for <code>0 : R'</code> and to prove it for all terms of the form <code>x ^ 2 + S</code> under the assumption that the term <code>S</code> is a sum of squares in <code>R'</code>, for which the result has already been proved.</p>
<p>To see how it works, we can either use a concrete example of a type with semiring instance, like <code>ℤ</code>, or declare a variable which plays that role (note that we do not call it <code>R</code>, in order to avoid conflicts in future declarations).</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>variable {<span class="dt">R'</span> <span class="op">:</span> <span class="dt">Type</span>} [hR' <span class="op">:</span> <span class="dt">Semiring</span> <span class="dt">R'</span>]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#check @IsSumSq.rec R' _</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Since it is a bit long, the induction principle for <code>IsSumSq</code> is reproduced below. There, the <code>Prop</code>-valued function <code>motive</code> is to be thought of as a property of sums of squares in <code>R</code> that one wants to prove.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="op">@</span>IsSumSq.rec <span class="dt">R'</span> hR' <span class="op">:</span> ∀ {motive <span class="op">:</span> (a <span class="op">:</span> <span class="dt">R'</span>) → <span class="dt">IsSumSq</span> a → <span class="dt">Prop</span>},</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  motive <span class="dv">0</span> (_ <span class="op">:</span> <span class="dt">IsSumSq</span> <span class="dv">0</span>) →</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    (∀ (x <span class="dt">S</span> <span class="op">:</span> <span class="dt">R'</span>) (hS <span class="op">:</span> <span class="dt">IsSumSq</span> <span class="dt">S</span>), motive <span class="dt">S</span> hS → motive (x <span class="op">^</span> <span class="dv">2</span> <span class="op">+</span> <span class="dt">S</span>) (_ <span class="op">:</span> <span class="dt">IsSumSq</span> (x <span class="op">^</span> <span class="dv">2</span> <span class="op">+</span> <span class="dt">S</span>))) →</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>      ∀ {a <span class="op">:</span> <span class="dt">R'</span>} (t <span class="op">:</span> <span class="dt">IsSumSq</span> a), motive a t</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let us now see how to use induction on the type <code>IsSumSq</code> to prove certain properties of sums of squares in a semiring <code>R</code>. For example, to say that the sum of two sums of squares is itself a sum of squares, we write:</p>
<blockquote class="blockquote">
<p>IsSumSq S1 ∧ IsSumSq S2 → IsSumSq (S1 + S2)</p>
</blockquote>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>theorem <span class="dt">IsSumSq.Sum</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] {<span class="dt">S1</span> <span class="dt">S2</span> <span class="op">:</span> <span class="dt">R</span>} (h1 <span class="op">:</span> <span class="dt">IsSumSq</span> <span class="dt">S1</span>) (h2 <span class="op">:</span> <span class="dt">IsSumSq</span> <span class="dt">S2</span>) <span class="op">:</span> <span class="dt">IsSumSq</span> (<span class="dt">S1</span> <span class="op">+</span> <span class="dt">S2</span>) <span class="op">:=</span> by</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  induction h1 with  <span class="co">-- we prove that S1 + S2 is a sum of squares in R by induction on h1 (which is a proof that S1 is a sum of squares)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> zero <span class="ot">=&gt;</span>  <span class="co">-- the base step is S1 = 0, so S1 + S2 = 0</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    simp  <span class="co">-- we simplify 0 + S2 to S2</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    exact h2  <span class="co">-- we conclude using h2</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> add a <span class="dt">S</span> hS ih <span class="ot">=&gt;</span>  <span class="co">-- the inductive step is the case S1 = a ^ 2 + S, where S is a sum of squares and the induction hypothesis is that (S + S2) is a sum of squares: the goal is to prove that (a ^ 2 + S) + S2 is a sum of squares</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    rw [add_assoc]  <span class="co">-- rewrite using (a ^ 2 + S) + S2 = a ^ 2 + (S + S2)</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    exact IsSumSq.add a (<span class="dt">S</span> <span class="op">+</span> <span class="dt">S2</span>) ih  <span class="co">-- since a ^ 2 is a square and (S + S2) is a sum of squares by the induction hypothesis, we conclude using IsSumSq.add</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Likewise, if the semiring <code>R</code> is commutative, a product of sums of squares is a sum of squares. As we shall see, the assumption that <code>R</code> is commutative is used in our proof when applying <a href="https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/GroupPower/Basic.html#mul_pow"><code>mul_pow</code></a>. We make this apparent via a separate lemma.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>lemma <span class="dt">IsSumSq.ProdSqBySumSq</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">CommSemiring</span> <span class="dt">R</span>] {<span class="dt">S</span> <span class="op">:</span> <span class="dt">R</span>} (h <span class="op">:</span> <span class="dt">IsSumSq</span> <span class="dt">S</span>) {x <span class="op">:</span> <span class="dt">R</span>} <span class="op">:</span> <span class="dt">IsSumSq</span> (x <span class="op">^</span><span class="dv">2</span> <span class="op">*</span> <span class="dt">S</span>) <span class="op">:=</span> by</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  induction h with  <span class="co">-- we prove that x ^ 2 * S is a sum of squares by induction on h (which is a proof that S is a sum of squares)</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> zero <span class="ot">=&gt;</span>  <span class="co">-- the base step is S = 0 so x ^ 2 * S = x ^ 2 * 0</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    rw [mul_zero]  <span class="co">-- we simplify x ^ 2 * 0 to 0</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    exact IsSumSq.zero  <span class="co">-- we conclude using the fact that 0 is a sum of squares</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span>add a s _ ih <span class="ot">=&gt;</span>  <span class="co">-- the inducive step is the case S = a ^ 2 + s, where s is a sum of squares and the induction hypothesis is that (x ^ 2 * s) is a sum of squares: the goal is to prove that x ^ 2 * (a ^ 2 + s) is a sum of squares</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    rw [mul_add, ← mul_pow x a <span class="dv">2</span>]  <span class="co">-- rewrite using x ^ 2 * (a ^ 2 + s) = (x * a) ^ 2 + x ^ 2 * s</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    exact IsSumSq.add (x <span class="op">*</span> a) (x <span class="op">^</span> <span class="dv">2</span> <span class="op">*</span> s) ih  <span class="co">-- since (x * a) ^ 2 is a square and (x ^ 2 *  s) is a sum of squares by the induction hypothesis, we conclude using IsSumSq.add</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can now prove that, indeed, a product of sums of squares is a sum of squares:</p>
<blockquote class="blockquote">
<p>IsSumSq S1 ∧ IsSumSq S2 → IsSumSq (S1 * S2)</p>
</blockquote>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>theorem <span class="dt">IsSumSq.Prod</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">CommSemiring</span> <span class="dt">R</span>] {<span class="dt">S1</span> <span class="dt">S2</span> <span class="op">:</span> <span class="dt">R</span>} (h1 <span class="op">:</span> <span class="dt">IsSumSq</span> <span class="dt">S1</span>) (h2 <span class="op">:</span> <span class="dt">IsSumSq</span> <span class="dt">S2</span>) <span class="op">:</span> <span class="dt">IsSumSq</span> (<span class="dt">S1</span> <span class="op">*</span> <span class="dt">S2</span>) <span class="op">:=</span> by</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  induction h1 with  <span class="co">-- we prove that S1 * S2 is a sum of squares by induction on h (which is a proof that S1 is a sum of squares)</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> zero <span class="ot">=&gt;</span>  <span class="co">-- -- the base step is S1 = 0 so S1 * S2 = 0 * S2</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    rw [zero_mul]  <span class="co">-- we simplify 0 * S2 to 0</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    exact IsSumSq.zero  <span class="co">-- we conclude using the fact that 0 is a sum of squares</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> add a <span class="dt">S</span> hS ih <span class="ot">=&gt;</span>  <span class="co">-- the inducive step is the case S1 = a ^ 2 + S, where S is a sum of squares and the induction hypothesis is that (S * S2) is a sum of squares: the goal is to prove that (a ^ 2 + S) * S2 is a sum of squares</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    rw [add_mul]  <span class="co">-- rewrite using (a ^ 2 + S) * S2 = a ^ 2 * S2 + S * S2</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    apply <span class="dt">IsSumSq.Sum</span> _ _  <span class="co">-- since a sum of sums of squares is a sum of squares, in order to prove that (a ^ 2 * S2) + (S * S2) is a sum of squares, it suffices to prove that (a ^ 2 * S2) and (S * S2) are both sums of squares</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    · exact <span class="dt">IsSumSq.ProdSqBySumSq</span> h2  <span class="co">-- the fact that (a ^ 2 * S2) is a sum of squares when S2 is a sum of squares was proved in IsSumSq.ProdSqBySumSq</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    · exact ih  <span class="co">-- the fact that (S * S2) is a sum of squares is the induction hypothesis</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="using-an-existential-predicate" class="level2">
<h2 class="anchored" data-anchor-id="using-an-existential-predicate">Using an existential predicate</h2>
<p>We now show that we could also define <code>IsSumSq S</code> by asking that it be a return value of the function <code>SumSq</code> defined in <a href="Defs.md">SumSq.Defs</a>. More precicely, we prove that, given a term <code>S</code> in a semiring <code>R</code>, the following equivalence holds:</p>
<blockquote class="blockquote">
<p>IsSumSq S ↔︎ (∃ L : List R, SumSq L = S)</p>
</blockquote>
<p>We begin with the first implication: starting from <code>S : R</code> such that <code>IsSumSq S</code> has a proof, we want to construct a list <code>L : List R</code> such that <code>SumSq L = S</code>. Since <code>IsSumSq S</code>is defined inductively, we can do this by induction on the proof of the proposition <code>IsSumSq S</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>lemma <span class="dt">IsSumSqToExistList</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] (<span class="dt">S</span> <span class="op">:</span> <span class="dt">R</span>) (hS <span class="op">:</span> <span class="dt">IsSumSq</span> <span class="dt">S</span>) <span class="op">:</span> (∃ <span class="dt">L</span> <span class="op">:</span> <span class="dt">List</span> <span class="dt">R</span>, <span class="dt">SumSq</span> <span class="dt">L</span> <span class="ot">=</span> <span class="dt">S</span>) <span class="op">:=</span> by</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  induction hS with  <span class="co">-- we prove the result by induction on hS (which is a proof that S is a sum of squares)</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> zero <span class="ot">=&gt;</span>  <span class="co">-- the base case is when S = 0</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    exact ⟨[], rfl⟩  <span class="co">-- we can use L = [] to prove that ∃ L, SumSq L = 0</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- use []  -- instead of exact ⟨[], rfl⟩, we can write use [] followed by rfl</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- rfl</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> add a s _ ih <span class="ot">=&gt;</span>  <span class="co">-- the inductive step is when S = a ^2 + s, where s is a sum of squares and the induction hypothesis is that there exists a list L such that SumSq L = s</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    rcases ih with ⟨l, hl⟩  <span class="co">-- we extract from ih a list l such that SumSq l = s</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    rw [← hl]  <span class="co">-- we rewrite the goal using SumSq l = s</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    use (<span class="ot">a ::</span> l)  <span class="co">-- We claim that we can use the list L = (a :: l) to show that there exists a list L such thatt SumSq L = a ^ 2 + SumSq l</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    rfl  <span class="co">-- indeed the result is true by definition of the function SumSq</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>From this and Lemma <code>SumSqListIsSumSq</code> proved in <a href="#using-an-inductive-predicate">the first section</a>, we can prove the equivalence that we wanted.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>theorem <span class="dt">IsSumSq.Char</span> (<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>) [<span class="dt">Semiring</span> <span class="dt">R</span>] (<span class="dt">S</span> <span class="op">:</span> <span class="dt">R</span>) <span class="op">:</span> <span class="dt">IsSumSq</span> <span class="dt">S</span> ↔ (∃ <span class="dt">L</span> <span class="op">:</span> <span class="dt">List</span> <span class="dt">R</span>, <span class="dt">SumSq</span> <span class="dt">L</span> <span class="ot">=</span> <span class="dt">S</span>) <span class="op">:=</span> by</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  constructor  <span class="co">-- this tactic splits the equivalence ↔ into two implications</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  · apply <span class="dt">IsSumSqToExistList</span>  <span class="co">-- the first implication is proven using the lemma IsSumSqToExistList</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- intro hS  -- instead of the apply tactic, we can use intro followed by exact</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- exact IsSumSqToExistList S hS</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  · intro h  <span class="co">-- to prove the second implication , let h be a proof of the fact that there exists a list L such that SumSq L = S</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    rcases h with ⟨<span class="dt">L</span>, hL⟩  <span class="co">-- we extract from h a list L such that SumSq L = S</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    rw [← hL]  <span class="co">-- we rewrite the goal using SumSq L = S</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    exact <span class="dt">SumSqListIsSumSq</span> <span class="dt">L</span>  <span class="co">-- we close the goal by applying a lemma that we already proved, which says that SumSq L is of type IsSumSq</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="as-a-set" class="level2">
<h2 class="anchored" data-anchor-id="as-a-set">As a set</h2>
<p>Recall that, given a type <code>R</code>, a term of type <a href="https://leanprover-community.github.io/mathlib4_docs/Mathlib/Init/Set.html"><code>Set R</code></a> is by definition a predicate <code>R → Prop</code>. But it comes with a series of extra functions, such as <a href="https://leanprover-community.github.io/mathlib4_docs/Mathlib/Init/Set.html#Set.Mem"><code>Set.Mem</code></a> to define membership in a set. And Lean provides a way to define sets from predicates, with a syntax that is familiar to mathematicians.</p>
<p>For example, to the predicate <code>IsSumSq : R → Prop</code>, there is associated the set <code>{S : R | IsSumSq S}</code>, which we can think of as <em>consisting of terms <code>S : R</code> such that <code>IsSumSq S</code> has a proof</em>. More concretely, <code>(0 : R) ∈ {S : R | IsSumSq S}</code> is definitionally equal to the proposition <code>IsSumSq 0</code> (see example below).</p>
<p>The upshot of using the type <code>Set R</code> is that it gives access to type-theoretic notation (the symbols <code>∈</code>, <code>∩</code>, <code>∪</code> <em>etc</em>). Note that it is convenient, in the definition of the function <code>SumSqSet : R → Set R</code>, to now make the variable <code>R</code> explicit.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>def <span class="dt">SumSqSet</span> (<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>) [<span class="dt">Semiring</span> <span class="dt">R</span>] <span class="op">:</span> <span class="dt">Set</span> <span class="dt">R</span> <span class="op">:=</span> {<span class="dt">S</span> <span class="op">:</span> <span class="dt">R</span> <span class="op">|</span> <span class="dt">IsSumSq</span> <span class="dt">S</span>}</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#check @SumSqSet  -- SumSqSet : (R : Type) → [inst : Semiring R] → Set R</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#check @SumSqSet ℤ  -- @SumSqSet ℤ : [inst : Semiring ℤ] → Set ℤ</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#check @SumSqSet ℤ _  -- SumSqSet ℤ : Set ℤ</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#check SumSqSet ℤ  -- SumSqSet ℤ : Set ℤ</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#check 0 ∈ SumSqSet ℤ  -- 0 ∈ SumSqSet ℤ : Prop</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Alternately, the set of sums of squares can be obtained from the predicate <code>IsSumSq</code> using the function <a href="https://leanprover-community.github.io/mathlib4_docs/Mathlib/Init/Set.html#setOf"><code>setOf</code></a>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>def <span class="dt">SumSqSet'</span> (<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>) [<span class="dt">Semiring</span> <span class="dt">R</span>] <span class="op">:</span> <span class="dt">Set</span> <span class="dt">R</span> <span class="op">:=</span> setOf <span class="dt">IsSumSq</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#check @SumSqSet' -- SumSqSet' : (R : Type) → [inst : Semiring R] → Set R</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#check @SumSqSet' ℤ  -- @SumSqSet' ℤ : [inst : Semiring ℤ] → Set ℤ</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#check @SumSqSet' ℤ _  -- SumSqSet' ℤ : Set ℤ</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#check SumSqSet' ℤ  -- SumSqSet' ℤ : Set ℤ</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#check 0 ∈ SumSqSet' ℤ  -- 0 ∈ SumSqSet' ℤ : Prop</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We could have used the set-theoretic notation earlier if we had declared <code>IsSumSq</code> in the following way, replacing <code>R → Prop</code> with <code>Set R</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>inductive <span class="dt">IsSumSq</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] <span class="op">:</span> <span class="dt">Set</span> <span class="dt">R</span> <span class="op">:=</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> zero <span class="op">:</span> <span class="dt">IsSumSq</span> (<span class="dv">0</span> <span class="op">:</span> <span class="dt">R</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> add (x <span class="dt">S</span> <span class="op">:</span> <span class="dt">R</span>) (hS <span class="op">:</span> <span class="dt">IsSumSq</span> <span class="dt">S</span>) <span class="op">:</span> <span class="dt">IsSumSq</span> (x <span class="op">^</span> <span class="dv">2</span> <span class="op">+</span> <span class="dt">S</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>However, it is not clear that this is a better option. Indeed, if we do that, then <code>(0 : R) ∈ IsSumSq</code> type-checks, but it does not read very naturally compared to <code>(0 : R) ∈ SumSq R</code>. By definition, the latter means <code>(0 : R) ∈ {S : R | IsSumSq S}</code>, and this means that <code>IsSumSq (0 : R)</code> has a proof.</p>
<p>Here is a proof that <code>(0 : R) ∈ SumSq R</code>. As we can see, it uses the fact that this is definitionally equal to the proposition <code>IsSumSq (0 : R)</code>.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>example {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] <span class="op">:</span> <span class="dv">0</span> ∈ <span class="dt">SumSqSet</span> <span class="dt">R</span> <span class="op">:=</span> by  <span class="co">-- the goal is 0 ∈ SumSqSet R (note that Lean identifies the term 0 as being of type R)</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  dsimp [<span class="dt">SumSqSet</span>]  <span class="co">-- simplifies the goal to 0 ∈ {a | IsSumSq a}, using the definition of SumSqSet</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  change <span class="dt">IsSumSq</span> <span class="dv">0</span>  <span class="co">-- changes the goal to IsSumSq 0, which is definitionally equal to 0 ∈ {a | IsSumSq a}</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  exact IsSumSq.zero  <span class="co">-- this closes the goal because IsSumSq.zero is the proof that 0 is a sum of squares in R</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can now rewrite the theorems above in set-theoretic notation. All of them have already been proved, so we close the goal with an <code>exact</code> tactic every time.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>theorem <span class="dt">SumSqSet.Sum</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] {<span class="dt">S1</span> <span class="dt">S2</span> <span class="op">:</span> <span class="dt">R</span>} (h1 <span class="op">:</span> <span class="dt">S1</span> ∈ <span class="dt">SumSqSet</span> <span class="dt">R</span>) (h2 <span class="op">:</span> <span class="dt">S2</span> ∈ <span class="dt">SumSqSet</span> <span class="dt">R</span>) <span class="op">:</span> (<span class="dt">S1</span> <span class="op">+</span> <span class="dt">S2</span>) ∈ <span class="dt">SumSqSet</span> <span class="dt">R</span>  <span class="op">:=</span> by</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  exact <span class="dt">IsSumSq.Sum</span> h1 h2</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>lemma <span class="dt">SumSqSet.ProdSqBySumSq</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">CommSemiring</span> <span class="dt">R</span>] {<span class="dt">S</span> <span class="op">:</span> <span class="dt">R</span>} (h <span class="op">:</span> <span class="dt">S</span> ∈ <span class="dt">SumSqSet</span> <span class="dt">R</span>) {x <span class="op">:</span> <span class="dt">R</span>} <span class="op">:</span> (x <span class="op">^</span><span class="dv">2</span> <span class="op">*</span> <span class="dt">S</span>) ∈ <span class="dt">SumSqSet</span> <span class="dt">R</span> <span class="op">:=</span> by</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  exact <span class="dt">IsSumSq.ProdSqBySumSq</span> h</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>theorem <span class="dt">SumSqSet.Prod</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">CommSemiring</span> <span class="dt">R</span>] {<span class="dt">S1</span> <span class="dt">S2</span> <span class="op">:</span> <span class="dt">R</span>} (h1 <span class="op">:</span> <span class="dt">S1</span> ∈ <span class="dt">SumSqSet</span> <span class="dt">R</span>) (h2 <span class="op">:</span> <span class="dt">S2</span> ∈ <span class="dt">SumSqSet</span> <span class="dt">R</span>) <span class="op">:</span>(<span class="dt">S1</span> <span class="op">*</span> <span class="dt">S2</span>) ∈ <span class="dt">SumSqSet</span> <span class="dt">R</span> <span class="op">:=</span> by</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>  exact <span class="dt">IsSumSq.Prod</span> h1 h2</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To conclude this subsection, we point out that we could have made the variable <code>R</code> explicit in the declaration <code>IsSumSq</code>. It makes the notation a little bit heavier, but it can be useful when declaring subtypes (see <a href="#as-a-subtype">below</a>).</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>inductive <span class="dt">IsSumSqExpl</span> (<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>) [<span class="dt">Semiring</span> <span class="dt">R</span>] <span class="op">:</span> <span class="dt">R</span> → <span class="dt">Prop</span> <span class="op">:=</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> zero <span class="op">:</span> <span class="dt">IsSumSqExpl</span> <span class="dt">R</span> (<span class="dv">0</span> <span class="op">:</span> <span class="dt">R</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> add (x <span class="dt">S</span> <span class="op">:</span> <span class="dt">R</span>) (hS <span class="op">:</span> <span class="dt">IsSumSqExpl</span> <span class="dt">R</span> <span class="dt">S</span>) <span class="op">:</span> <span class="dt">IsSumSqExpl</span> <span class="dt">R</span> (x <span class="op">^</span> <span class="dv">2</span> <span class="op">+</span> <span class="dt">S</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="as-a-subtype" class="level2">
<h2 class="anchored" data-anchor-id="as-a-subtype">As a subtype</h2>
<p>Similarly to the way the set <code>SumSqSet R</code> is defined (using the syntax <code>{S : R | IsSumSq S}</code>), Lean provides a way to define sums of squares as a <a href="https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Subtype">subtype</a> of <code>R</code>, using the predicate <code>IsSumSq : R → Prop</code> and a syntax similar to the one seen <a href="#as-a-set">earlier</a> for <code>SumSqSet R</code> (namely <code>{S : R | IsSumSq R}</code>).</p>
<p>The first difference is that the return type is now <code>Type</code>, as opposed to <code>Set R</code>. Note that we are still making the variable <code>R</code> explicit here.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>def <span class="dt">SumSqType</span> (<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>) [<span class="dt">Semiring</span> <span class="dt">R</span>] <span class="op">:</span> <span class="dt">Type</span> <span class="op">:=</span> {<span class="dt">S</span> <span class="op">:</span> <span class="dt">R</span> <span class="op">//</span> <span class="dt">IsSumSq</span> <span class="dt">S</span>}</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#check @SumSqType</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>By definition of the subtype associated to the predicate <code>IsSumSq</code>, a term <code>S : SumSqType R</code> is a pair <code>⟨S.val, S.property⟩</code> consisting of a term <code>S.val : R</code> and a term <code>S.property : IsSumSq S</code> (meaning a proof of the proposition <code>IsSumSq S</code>). In particular, to declare such a term <code>S</code>, we need to specify both <code>S.val</code> and <code>S.property</code>.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#check (⟨0, IsSumSq.zero⟩ : SumSqType ℤ)</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- { val := 0, property := (_ : IsSumSq 0) } : { S // IsSumSq S }</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It seems reasonable to imagine that, when it comes to formalising proofs about sums of squares in <code>R</code>, it will be less natural for mathematicians to work with the subtype <code>IsSumSqType R</code> than with the set <code>IsSumSqSet R</code>. For example, when working with subtypes, to say that <em>the sum of two sums of squares is a sum of squares</em>, is equivalent to <em>declaring a function</em> <code>SumSqType.Add {R : Type} [Semiring R] : SumSqType R → SumSqType R → SumSqType R</code>, with <code>SumSq.Add S1 S2</code> defined as <code>⟨S1.val + S2.val, IsSumSq.Sum S1.property S2.property⟩</code>.</p>
<p>As we can see, this formalises the desired result, but in a way that is not (yet?) the usual one in mathematics. Instead, it is directly inspired by the methods of functional programming. Exploring those methods further, we can perform other constructions that are common in functional programming and object-oriented programming, such as <em>instantiating a class</em> on the type <code>SumSqType</code>. For example the class <a href="https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Add"><code>Add</code></a>, which will equip the type <code>SumSqType R</code> with a function <code>SumSqType R → SumSqType R → SumSqType R</code>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>def <span class="dt">Addition</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] (<span class="dt">S1</span> <span class="dt">S2</span> <span class="op">:</span> <span class="dt">SumSqType</span> <span class="dt">R</span>) <span class="op">:</span> <span class="dt">SumSqType</span> <span class="dt">R</span> <span class="op">:=</span> ⟨S1.val <span class="op">+</span> S2.val, <span class="dt">IsSumSq.Sum</span> S1.property S2.property⟩</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] <span class="op">:</span> <span class="dt">Add</span> (<span class="dt">SumSqType</span> <span class="dt">R</span>) <span class="op">:=</span> ⟨<span class="dt">Addition</span>⟩</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As a consequence, we now have access to the methods of the class <code>Add</code>. For example, we can use the notation <code>+</code> without declaring it as such for the function <code>Addition</code>.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>def <span class="dt">Double</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] (<span class="dt">S</span> <span class="op">:</span> <span class="dt">SumSqType</span> <span class="dt">R</span>) <span class="op">:</span> <span class="dt">SumSqType</span> <span class="dt">R</span> <span class="op">:=</span> <span class="dt">S</span> <span class="op">+</span> <span class="dt">S</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>example {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] (<span class="dt">S</span> <span class="op">:</span> <span class="dt">SumSqType</span> <span class="dt">R</span>) <span class="op">:</span> <span class="dt">Double</span> <span class="dt">S</span> <span class="ot">=</span> <span class="dt">Addition</span> <span class="dt">S</span> <span class="dt">S</span> <span class="op">:=</span> by rfl</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that the instantiation can also be done directly, without defining the function <code>Addition</code>. And we may give it a name if we want, and/or use a slightly different syntax (<code>add</code> is the unique attribute of the class <a href="https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Add"><code>Add</code></a>).</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] <span class="op">:</span> <span class="dt">Add</span> (<span class="dt">SumSqType</span> <span class="dt">R</span>) <span class="op">:=</span> ⟨fun <span class="dt">S1</span> <span class="dt">S2</span> <span class="ot">=&gt;</span> ⟨S1.val <span class="op">+</span> S2.val, <span class="dt">IsSumSq.Sum</span> S1.property S2.property⟩⟩</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SumSqTypeAddition</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] <span class="op">:</span> <span class="dt">Add</span> (<span class="dt">SumSqType</span> <span class="dt">R</span>) <span class="kw">where</span> add <span class="dt">S1</span> <span class="dt">S2</span> <span class="op">:=</span> ⟨S1.val <span class="op">+</span> S2.val, <span class="dt">IsSumSq.Sum</span> S1.property S2.property⟩</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Another advantage of defining sums of squares as a subtype is that we can make the type <code>SumSqType R</code> an instance of the <code>Repr</code> class, making it possible to use <code>#eval</code> on terms of type <code>SumSqType ℤ</code> or <code>SumSqType ℚ</code> (all terms of type <code>SumSqType R</code> where <code>R</code> is a <em>concrete</em> type).</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#check SumSqType ℤ</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] [<span class="dt">Repr</span> <span class="dt">R</span>] <span class="op">:</span> <span class="dt">Repr</span> (<span class="dt">SumSqType</span> <span class="dt">R</span>) <span class="kw">where</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  reprPrec <span class="op">:=</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    fun <span class="dt">S</span> _ <span class="ot">=&gt;</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>      repr S.val <span class="op">++</span> <span class="st">" is a sum of squares because the property IsSumSq "</span> <span class="op">++</span> repr S.val <span class="op">++</span> <span class="st">" has been proven."</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>def aTermOfSumSqTypeInZ <span class="op">:</span> <span class="dt">SumSqType</span> ℤ <span class="op">:=</span> ⟨<span class="dv">0</span>, IsSumSq.zero⟩</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#check aTermOfSumSqTypeInZ.1  -- ↑aTermOfSumSqTypeInZ : ℤ</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#check aTermOfSumSqTypeInZ.2  -- aTermOfSumSqTypeInZ.property : IsSumSq ↑aTermOfSumSqTypeInZ</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a><span class="pp">#eval aTermOfSumSqTypeInZ.1  -- 0</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a><span class="pp">#eval aTermOfSumSqTypeInZ  -- 0 is a sum of squares because the property IsSumSq 0 has been proven.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Similarly, we can register a <code>Decidable</code> instance on the proposition <code>IsSumSq (0 : R)</code>.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] <span class="op">:</span> <span class="dt">Decidable</span> (<span class="dt">IsSumSq</span> (<span class="dv">0</span> <span class="op">:</span> <span class="dt">R</span>)) <span class="op">:=</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  Decidable.isTrue (IsSumSq.zero)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#check IsSumSq (0 : ℤ)  -- IsSumSq 0 : Prop</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#eval IsSumSq (0 : ℤ)  -- true</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#eval decide (IsSumSq (0 : ℤ))  -- true</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#check IsSumSq (0 : R')  -- IsSumSq 0 : Prop</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- #eval IsSumSq (0 : R')  -- (kernel) declaration has free variables '_eval'</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We conclude this subsection by showing one advantage of making the type <code>R</code> explicit in the definition of <code>IsSumSqExpl</code>. Namely that it gives us access to the function <a href="https://leanprover-community.github.io/mathlib4_docs/Init/Prelude.html#Subtype"><code>Subtype</code></a>, which creates the subtype of sums of squares from the predicate <code>IsSumSq R : R → Prop</code>.</p>
<p>This was not necessary earlier, due to the use of the syntax <code>{S : R // IsSumSq S}</code>, which is capable of inferring what is needed in order to construct the required type.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>def <span class="dt">SumSqType'</span> (<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>) [<span class="dt">Semiring</span> <span class="dt">R</span>] <span class="op">:</span> <span class="dt">Type</span> <span class="op">:=</span> <span class="dt">Subtype</span> (<span class="dt">IsSumSqExpl</span> <span class="dt">R</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#check @SumSqType'  -- SumSqType' : (R : Type) → [inst : Semiring R] → Type</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#check (⟨0, IsSumSqExpl.zero⟩ : SumSqType' ℤ)</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- { val := 0, property := (_ : IsSumSqExpl ℤ 0) } : Subtype (IsSumSqExpl ℤ)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="exercises" class="level2">
<h2 class="anchored" data-anchor-id="exercises">Exercises</h2>
<section id="exercise-1" class="level3">
<h3 class="anchored" data-anchor-id="exercise-1">Exercise 1</h3>
<p>Let <code>R</code> be a semiring and let <code>S</code> be a term in <code>R</code>. Prove that Proposition <code>IsSumSq S</code> is equivalent to Proposition <code>IsSumSq' S</code>, where <code>IsSumSq'</code> is the predicate defined inductively as follows:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell code-with-copy"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>inductive <span class="dt">IsSumSq'</span> {<span class="dt">R</span> <span class="op">:</span> <span class="dt">Type</span>} [<span class="dt">Semiring</span> <span class="dt">R</span>] <span class="op">:</span> <span class="dt">R</span> → <span class="dt">Prop</span> <span class="op">:=</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> sq (x <span class="op">:</span> <span class="dt">R</span>)<span class="op">:</span> <span class="dt">IsSumSq</span> (x <span class="op">^</span> <span class="dv">2</span> <span class="op">:</span> <span class="dt">R</span>)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> add (<span class="dt">S1</span> <span class="dt">S2</span> <span class="op">:</span> <span class="dt">R</span>) (h1 <span class="op">:</span> <span class="dt">IsSumSq</span> <span class="dt">S1</span>) (h2 <span class="op">:</span> <span class="dt">IsSumSq</span> <span class="dt">S2</span>) <span class="op">:</span> <span class="dt">IsSumSq</span> (<span class="dt">S1</span> <span class="op">+</span> <span class="dt">S2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that this definition may be more intuitive than the one we gave in <a href="#using-an-inductive-predicate">the first section</a>. But it might be less convenient to work with. Indeed, when proving a statement by induction on the proof of <code>IsSumSq' S</code>, then in the first case, we would have to prove it not only for <code>S = 0</code>, but in all cases <code>S = x ^ 2</code> for some <code>x : R</code>.</p>
</section>
<section id="exercise-2" class="level3">
<h3 class="anchored" data-anchor-id="exercise-2">Exercise 2</h3>
<p>Let <code>R</code> be a semiring and let <code>S</code> be a term in <code>R</code>. Write a (direct) proof of the implication</p>
<blockquote class="blockquote">
<p>(∃ L : List R, SumSq L = S) → IsSumSq S</p>
</blockquote>
<p>and ask yourself whether having an existential quantifier in the assumption makes things complicated. Try using Lemma <code>SumSqListIsSumSq</code> and the second implication of the equivalence <code>IsSumSq.Char</code> to prove the result. You can then see that the approach there is to first prove <code>IsSumSq (SumSq L)</code> and from this deduce a proof of the implication. A formalisation of this last statement is suggested in <a href="#exercise-3">Exercise 3</a>.</p>
</section>
<section id="exercise-3" class="level3">
<h3 class="anchored" data-anchor-id="exercise-3">Exercise 3</h3>
<p>Let <code>S T</code> be types. Let <code>P : T → Prop</code> be a predicate on <code>T</code> and let <code>f : S → T</code> be a function from <code>S</code> to <code>T</code>. Assume that the proposition <code>∀ x : S, P (f x)</code> has a proof and that the proposition <code>∀ y : T, ∃ x : S, y = f x</code> has a proof. Show that the proposition <code>∀ y : T, P y</code> has a proof.</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>